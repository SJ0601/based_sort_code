void HeadAdjust(int *a,int k,int n)//时间复杂度：logn，将以非叶节点K为根节点的子树调整为大根堆
                                    //升序用大根堆，降序用小根堆（原因：排列升序，只需将大根堆堆顶元素和数组最后一个元素交换，再重新调整堆即可，调整时间复杂度：logn
                                    //                            但是，如果使用小根堆，要想输出升序，需要排除堆顶最小元素后继续对剩余元素进行建小根堆，时间复杂度nlogn
                                    //                            如果直接将小根堆堆顶元素和数组最后一个元素交换，再调整其他，则输出的是降序）
{
    int temp = a[k];//存下k节点，防止被覆盖
    for(int i = 2*k+1;i < n;i=2*i+1)//k的左孩子：2*k-1
    {
        if(i < n-1 && a[i]<a[i+1])//比较k节点的左右孩子谁更大，i<n-1是为了保证有右孩子，即i+1<n
        {
            i++;
        }
        if(temp < a[i])//k节点的值小于孩子节点
        {
            a[k] = a[i];
            k = i;//k是需要调整的节点
        }else//满足k比左右孩子都大，直接跳出
        {
            break;
        }
    }
    a[k] = temp;
}
void buildMaxHeap(int *a,int n)//时间复杂度：n*调整的时间复杂度
{
    for(int i = n/2-1;i>=0;i--)//从最后一个非叶节点(n/2-1，从0开始)开始，从后往前调用子函数调整非叶节点
    {
        HeadAdjust(a,i,n);
    }
}
void pipe_sort(int *a,int n)
{
    buildMaxHeap(a,n);//建立大根堆
    for(int i = n-1;i >0;i--)
    {
        swap(a[0],a[i]);//交换堆顶和堆底元素，将最大的放到数组末尾，形成升序
        HeadAdjust(a,0,i);//i以及后面的元素已经有序了，只需要调整到i-1，注意0~i-1，此处传的是长度=i
    }
}